/*
 * Copyright (c) 2016. Bottle Rocket LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ionicframework.auth;

import android.annotation.TargetApi;
import android.content.Context;
import android.os.Build;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.util.Log;

import com.bottlerocketstudios.vault.EncryptionConstants;
import com.bottlerocketstudios.vault.keys.storage.KeychainAuthenticatedKeyStorage;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.cert.CertificateException;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

/**
 * Use Android Keystore to keep the SecretKey. Requires user authentication to be enabled and
 * requires re-authentication at specified intervals.
 */
public class IonicKeychainAuthenticatedStorage extends KeychainAuthenticatedKeyStorage implements IonicKeyStorage {
    private static final String TAG = "IonicKeychainStorage";

    private final String mKeyLock = "keyLock";
    private SecretKey mSecretKey;

    private final String mKeyAlias;
    private final String mAlgorithm;
    private final String mBlockMode;
    private final String mPadding;
    private final int mAuthDurationSeconds;

    IonicKeychainAuthenticatedStorage(String keyAlias, String algorithm, String blockMode, String padding, int authDurationSeconds) {
        super(keyAlias, algorithm, blockMode, padding, authDurationSeconds);
        mKeyAlias = keyAlias;
        mAlgorithm = algorithm;
        mBlockMode = blockMode;
        mPadding = padding;
        mAuthDurationSeconds = authDurationSeconds;
        mSecretKey = null;
    }

    @Override
    public SecretKey loadKey(Context context) {
        if (mSecretKey != null) {
            return mSecretKey;
        }
        mSecretKey = super.loadKey(context);
        return mSecretKey;
    }

    @Override
    public boolean saveKey(Context context, SecretKey secretKey) {
        if (secretKey != null) {
            throw new IllegalArgumentException("Cannot be manually keyed. The key is generated by the Keystore itself. The argument secretKey must be null.");
        }
        return automaticallyCreateKey();
    }

    @TargetApi(Build.VERSION_CODES.M)
    private boolean automaticallyCreateKey() {
        synchronized (mKeyLock) {
            try {
                KeyStore keyStore = KeyStore.getInstance(EncryptionConstants.ANDROID_KEY_STORE);
                keyStore.load(null);
                KeyGenerator keyGenerator = KeyGenerator.getInstance(mAlgorithm, EncryptionConstants.ANDROID_KEY_STORE);

                keyGenerator.init(new KeyGenParameterSpec.Builder(mKeyAlias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                        .setBlockModes(mBlockMode)
                        // TODO: maybe use keypair to allow for unauthed writes?
                        //.setUserAuthenticationRequired(true)
                        .setUserAuthenticationValidityDurationSeconds(mAuthDurationSeconds)
                        .setEncryptionPaddings(mPadding)
                        .build());

                mSecretKey = keyGenerator.generateKey();
                return mSecretKey != null;
            } catch (KeyStoreException e) {
                Log.e(TAG, "Caught java.security.KeyStoreException", e);
            } catch (CertificateException e) {
                Log.e(TAG, "Caught java.security.cert.CertificateException", e);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, "Caught java.security.NoSuchAlgorithmException", e);
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, "Caught java.security.InvalidAlgorithmParameterException", e);
            } catch (NoSuchProviderException e) {
                Log.e(TAG, "Caught java.security.NoSuchProviderException", e);
            } catch (IOException e) {
                Log.e(TAG, "Caught java.io.IOException", e);
            }
        }
        return false;
    }

    public boolean isLocked() {
        return mSecretKey == null;
    }

    public void lock() {
        mSecretKey = null;
    }
}

